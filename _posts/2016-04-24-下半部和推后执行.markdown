## 正文:<br>

1. 下半部的任务就是执行与中断处理密切相关但中断处理程序本身不执行的工作。<br>
2. 驱动程序开发者必须把中断上，下半部的处理工作分好。<br>
3. 下半部执行的关键在于当它们运行时可以响应所有中断。<br>
4. 软中断必须在编译期间就进行静态注册，而tasklet可以通过代码进行动态注册。<br>
5. 内核提供了三种不同形式的下半部实现机制：软中断，tasklet,工作队列。<br>
6. 可以用于将工作推后执行的机制是内核定时器。<br>
7. 一个软中断不会抢占另一个软中断，唯一可以抢占软中断的是中断处理程序。其他软中断可以在其他处理器上同时执行。<br>
8. 一个注册的软中断必须在被标记后才会执行。通常中断处理程序在返回前标记它的软中断。<br>
9. 待处理的软中断会被检查和执行的地方：从一个硬件中断代码处返回时；在ksoftirqd内核线程中；在那些显式检查和执行待处理的软中断的代码中。<br>
10. 软中断保留给系统中对时间要求最严格以及最重要的下半部使用，比如网络，SCSI.此外，内核定时器，tasklet都是建立在软中断上的。<br>
11. 软中断处理程序执行时，允许响应中断，但它自己不能休眠。在一个处理程序运行的时候，当前处理器上的软中断被禁止，但其他处理器仍然可以执行别的软中断。<br>
12. 使用tasklet时，同一个处理程序的多个实例不能在多个处理器上同时运行。<br>
13. tasklet由tasklet_schedule()和tasklet_hi_schedule()函数进行调度。<br>
14. 一个tasklet总在调度它的处理器上执行，这是希望能更好的利用处理器的高速缓存。<br>
15. 每个处理器都有一组辅助处理软中断的内核线程，当内核中出现大量软中断的时候，这些内核线程就会辅助处理他们。<br>
16. 内核不会立即处理重新触发的软中断，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最低优先级上运行（nice值是19），这能避免它们跟其他重要的任务抢夺资源。<br>
17. 工作队列交由一个内核线程在进程上下文执行，它允许重新调度和睡眠。<br>
18. 尽管工作队列处理函数运行在进程上下文中，但它不能访问用户空间，因为内核线程在用户空间没有相关的内存映射。<br>


---
