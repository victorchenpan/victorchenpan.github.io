1. **运算符重载**实质就是函数重载，是另一种形式的函数调用而已！只是运算符重载的函数参数就是该运算符涉及的操作数。
2. **友元**不是类的成员，但能直接访问类的所有成员，又不改变受访问类成员的访问权限。c++不是完全面向对象的语言！
3. 通过**友元**机制，一个类或函数可以直接访问另一个类的非公有成员。可以将全局函数，类，类的成员函数声明为友元。友元关系不能传递！友元关系是单向的，并且不能继承！
4. 运算符重载为成员函数最多有一个形参。而重载为友元函数时最多有两个形参！
5. 不能重载的运算符 (：:)(.) (.* )(？：)(sizeof) (typeid)
6. 参数化的函数称为**函数模板**，代表的是一个函数家族。函数模板不是一个实实在在的函数，它不产生任何执行代码。当编译系统在程序中发现有与函数模板相匹配的函数调用时，便产生一个重载函数，该重载函数的函数体与函数模板的体力相同，该重载函数称为模板函数。
7. **适配器** 是用来修改其他组件接口的STD组件，是带有一个参数的类模板。有容器适配器，迭代适配器，函数适配器。
8. **范型算法（algorithm）**，这些算法可以应用于多种容器类型上，而容器内的元素类型也可以多样化。STD的范型算法中有4类基本算法：变序型队列算法，非变序型队列算法，排序值算法
9. **迭代器（iterator）**,迭代器实际上是一种范化指针，如果迭代器指向了容器中的某一成员，那么迭代器将可以通过自增自减来遍历容器中所有成员。迭代器是联系算法和容器的媒介，是算法操作容器的接口。
10. **函数对象（function）又称仿函数**。函数对象将函数封装在一个对象中，使得它可作为参数传递给合适的STD算法。
11. **流** 指数据从一个位置流向另一个位置，流是字节的序列。
12. C++编译系统提供的**i/O流类库**含有2个平行基类：streambuf 和ios,所有的流类都是由他们派生出来的。
13. iostream包括操作所有I/O所需的基本信息，提供无格式支持的低级I/O和具有格式支持的高级I/O操作功能！
fstream头文件包含对文件I/O操作的有关信息。
strstream头文件包含对内存格式化I/O操作的有关信息。
stdiostream头文件包含混合使用C和C++风格的I/O操作有关信息。
14. 处理大容量文件最好使用无格式I/O.
15. 用ios类成员函数格式化，主要是通过对状态标志，输出宽度，填充字符以及输出精度的操作来完成输入/输出格式化。
16. 用操作符函数格式化。标准库的操作符函数专门操控这些状态，它们不属于任何类成员，定义在iomanip头文件中。操作符又称流操纵算子，或控制器函数。
17. 自定义类型对象的输入输出可以在类中对插入运算符<<与提取运算符进行重载！
18. 异常处理是C++语言中重要的错误处理机制，是提高程序容错性的手段。
19. **系统层次异常处理的标准设施**：
能够在异常发生时，在执行点抛出异常，并将有关异常信息以类型的形式传递到异常处理模块。建立模块间的异常通信机制。保证异常发生时释放所占系统资源。将异常处理代码从普通代码中分离。
20. try catch throw的实际联系是在程序运行时体现出来的。当抛出的异常找不到与之匹配的catch子句时，由系统函数terminate()通知用户异常未处理，系统终止程序运行。
21. C++的异常处理机制保证：在栈展开时，临时变量会自动释放，局部类对象的析构函数会自动调用。
22. 声明为explicit的构造函数禁止在隐式转换中使用
23. 对象的布局方式和他们的地址计算方式随编译器的不同而不同。
24. 如果系统有一个函数不具备异常安全性，整个系统就不具备异常安全性！异常安全函数即使发生异常也不会泄露资源或允许任何数据结构败坏。
25. 一个表面上看起来是inline的函数是否真是inline取决于你的建制环境，主要是编译器。
26. 将大多数inlining限制在小型被频繁调用的函数身上。
27. **句炳** 是一个整数值，系统用来标识对象数据的，是操作系统所提供的。
28. 将数据类型参数化来设计函数的机制称为函数模板。还有一种类模板，既类的数据成员也进行参数化。
29. 复制构造函数中的**浅复制与深复制**.
30. **静态成员** 是c++解决同一个类的不同对象之间数据和函数共享问题的机制。分为静态数据成员和静态成员函数。
31. 静态数据成员最好在类的实现部分进行初始化。
32. **this指针** 存放当前对象的起始地址。
33. **静态成员函数** 只能直接引用静态成员。如果静态成员函数中要使用非静态成员时，必须通过参数传递方式得到对象名，然后通过对象名来访问。
34. 析构函数不能重载。
35. 对于未给出构造函数，析构函数的类，如果不想让编译器自动生成，应该明令禁止！
36. 名字空间主要是解决程序中标识符名字冲突问题。
37. 不能通过**常对象**调用普通成员函数，只能调用常成员函数，它只能访问数据成员，不能修改数据成员的值，如果想改变某个数据成员，可将数据成员声明为**mutable**.
38. 一般来说，在类中出现了对象成员时，创建本类对象既要对对象成员进行初始化又要对本类对象的初始化！先调用对象成员的构造函数。析构函数的调用顺序刚好相反。
39. 派生类不会继承基类的构造函数和析构函数。
40. 定义派生类的构造函数时除了对派生类成员初始化外还必须调用基类的构造函数初始化基类的数据成员。如果派生类中有对象成员时，还应调用对象成员类的构造函数初始化对象成员。
41. 对于**构造函数**，要么在类内声明处用初始化列表全部给出数据成员的初始方式，要么只在类内声明构造函数，在类外可以部分数据成员用初始化列表进行初始化，部分数据成员在函数体内进行初始化！
42. 派生类析构函数—>对象成员析构函数—>基类析构函数。
43. class默认继承方式为私有继承。
44. 利用将直接基类的共同基类设置成**虚基类**，可避免继承二义性！此时该基类在内存中只有一个副本存在！
45. **多继承下**，在所有基类中先调用虚基类的构造函数。
46. 派生类的对象可以赋值给基类对象；派生类的对象可以初始化基类对象的引用；派生类对象的地址也可以赋给基类的指针。
47. **静态联编：**对象指针类型在编译阶段将指针名和成员函数彼此关联的过程。
48. **多态**指具有相似功能的不同函数使用同一个名称来实现！包括重载多态，强制多态，包含多态，参数多态！c++采用联编技术来支持多态。
49. **联编** 是指计算机程序自身彼此关联的过程，也就是把一个标识符名和一个存储地址联系在一起的过程。分为静态，动态联编。
50. **动态联编** 通过继承和虚函数来实现。运行时多态需要满足3个条件，一是类之间应满足类型兼容规则，二是同名声明虚函数，三是由成员函数来调用或者通过指针，引用来访问虚函数。
51. **virtual** 关键字只用在虚函数的声明中，在定义的时候不能用！虚函数派生下去还是虚函数。
52. 在类对象的内存中，首先是该类的虚函数表指针，然后才是对象数据。
53. 静态成员函数不能声明为虚函数；构造函数不能是虚函数；内联函数不能声明为虚函数；但析构函数往往被定义为虚函数。
54. 如果在派生类中没有重新定义虚函数，则派生类的对象将使用基类的虚函数代码。
55. 在派生类中重新定义虚函数时，必须保证函数值类型和参数与基类中的声明完全一致。
56. **抽象类** 专门作为基类派生新类，主要作用是将有关的派生类组织在一个继承层次结构中，由抽象类为它们提供一个公共的根。抽象类提供了处理各种不同派生类的统一接口，此接口就是纯虚函数。含有纯虚函数的类就是抽象类！
57. **纯虚函数** 是为了解决在基类中无法实现的函数，而在派生类中再给出函数的具体实现。
58. 声明指向抽象类的指针或引用，通过它们来指向并访问派生类对象。
59. 如果派生类没有给出全部纯虚函数的实现，继承了部分纯虚函数，这时的派生类仍然是一个抽象类！
